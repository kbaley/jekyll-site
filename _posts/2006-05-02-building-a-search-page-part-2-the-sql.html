---
layout: post
title: 'Building a search page, Part 2: The SQL'
date: 2006-05-02 16:58:00.000000000 -04:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  pvc_views: '902'
  dsq_thread_id: '362996976'
author:
  login: kyle6994
  email: kyle@baley.org
  display_name: Kyle Baley
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p><a href="http://kyle.baley.org/Downloads/SearchPontification.zip">download the source code</a>&nbsp;(292Kb)</p>
<div style="BORDER-RIGHT: darkgray 1px solid; PADDING-RIGHT: 0.5em; BORDER-TOP: darkgray 1px solid; PADDING-LEFT: 0.5em; FLOAT: right; PADDING-BOTTOM: 0.5em; MARGIN: 0.5em; BORDER-LEFT: darkgray 1px solid; WIDTH: 200px; PADDING-TOP: 0.5em; BORDER-BOTTOM: darkgray 1px solid; BACKGROUND-COLOR: #eeeeee"><a href="http://kyle.baley.org/articles/378.aspx">Part 1</a><br /><a href="http://kyle.baley.org/articles/379.aspx">Part 2: The SQL</a></div>
<p>In <a href="http://kyle.baley.org/articles/378.aspx">Part 1</a>, we established how our search was going to perform and described a sample domain object with some properties we will use in our search criteria. Here, we'll talk about the SQL that we'll be using to generate our search results.</p>
<p>To that end, there is code attached with the first draft of our search engine. It is functional in that it will allow you to specify some search criteria and display the results. It is pretty in that it is not. I'm the Salieri of UI; I can recognize when it's done right but am average (at best) at building them. For this example, I chose not to try.</p>
<p>I haven't addressed any of the client-side improvements mentioned in part one. But the topic of this article will be at the other end, in the database. The search results will be expanded upon in a future article. For now, we're interesting only in getting results.</p>
<p>Final cop-out: I don't usually use SqlDataSource in my web apps. The exception is for samples and demos which, frankly, is the only reason I can think of to use them. Having said that, they rock for samples and demos.</p>
<hr />
<p>Until relatively recently, I was under the impression that search queries had to be done using hard-coded SQL. There are two main reasons for this.</p>
<p>First is the multi-select listboxes and checkbox lists. With these, a user can select one or more items on which to filter. For example, let's say the user selects four different project types. That means, of course, he or she wants all Moos that have any of those project types attached.</p>
<p>In SQL, this translates to:</p>
<p><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">SELECT</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>*<br /></font></span><font size="2"><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">FROM</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Moo<br /></span><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">WHERE</span><span> </span>ProjectType <span style="COLOR: blue">IN</span> ( 1, 2, 3, 4 )</span></font></p>
<p>It's the IN criteria that presents a problem. We can't pass in a comma-delimited list to replace ( 1, 2, 3, 4 ). SQL Server simply doesn't allow this. It won't throw an error if you do this but trust me on this, it just doesn't work.</p>
<p>The second issue has to do with the part of the search screen where you specify how to search for the name. I.E. The radio button list where you specify "Starts with", "Ends with", etc.</p>
<p>In this case, there's no getting around the fact that we're going to need some conditional logic. And in SQL, that means either an IF statement or a CASE statement.</p>
<p>But each of these would need to occur in the WHERE clause. For example:</p>
<p><font size="2"><font face="Courier New"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue; FONT-FAMILY: 'Courier New'">SELECT&nbsp;&nbsp;&nbsp; </span>*<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue; FONT-FAMILY: 'Courier New'">FROM</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Moo<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue; FONT-FAMILY: 'Courier New'">WHERE</span></font></font><font size="2"><font face="Courier New"><span><br /></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue; FONT-FAMILY: 'Courier New'">IF</span> @searchMethod = 'startswith'<br /><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp; </span>Moo.Name <span style="COLOR: blue; FONT-FAMILY: 'Courier New'">LIKE</span> @name + '%'<br /><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: blue; FONT-FAMILY: 'Courier New'">ELSE</span> <span style="COLOR: blue; FONT-FAMILY: 'Courier New'">IF</span> @searchMethod = 'endswith'<br /><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>Moo.Name <span style="COLOR: blue; FONT-FAMILY: 'Courier New'">LIKE</span> '%' + @name<br /><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: blue; FONT-FAMILY: 'Courier New'">ELSE</span> <span style="COLOR: blue; FONT-FAMILY: 'Courier New'">IF</span> @searchMethod = 'isexactly'<br /><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>Moo.Name = @name<br /><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: blue; FONT-FAMILY: 'Courier New'">ELSE</span> <span style="COLOR: blue; FONT-FAMILY: 'Courier New'">IF</span> @searchMethod = 'notspecified'<br /><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>Moo.Name <span style="COLOR: blue; FONT-FAMILY: 'Courier New'">LIKE</span> '%'</font></font></p>
<p>And so on and so forth. But this SQL is, of course, just plain wrong. I don't mean wrong in the philosophical sense. I mean in the "it won't compile" sense. The same is true for putting a CASE statement in the WHERE clause in a similar fashion.</p>
<p>Alternatively, you could use the IF statement as follows:</p>
<p><font face="Courier New"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><font color="#0000ff">IF</font> @searchMethod = 'startswith'<br /></font></font><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: blue">SELECT</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>*<br /></font></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">FROM</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Moo<br /></font></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: blue">WHERE</span><span>&nbsp;&nbsp;&nbsp;&nbsp; </span>Moo.Name <span style="COLOR: blue">LIKE</span> @name + '%'<br /></font></span><font face="Courier New"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><font color="#0000ff">ELSE IF</font> @searchMethod = 'endswith'<br /></font></font><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: blue">SELECT</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>*<br /></font></span><font size="2"><span style="FONT-FAMILY: 'Courier New'"><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">FROM</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Moo<br /></span><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: blue">WHERE</span><span>&nbsp;&nbsp;&nbsp;&nbsp; </span>Moo.Name <span style="COLOR: blue">LIKE</span> '%' + @name</span></font></p>
<p>And so on and so forth. Granted this will work in this case but that's because of the lack of imagination I put into the example. There are other cases where a conditional in the WHERE clause is unavoidable. Besides, the actual SQL being executed in the various cases is a lot more complicated than in this example and having that copied and pasted throughout the stored procedure is nigh unmaintainable.</p>
<p>My solution to this problem was initially to build me a SQL statement in .NET code and execute it. This is usually a pretty reasonable approach. Easy to implement and easy to follow, even if the SQL that you generate isn't. A purist will tell you that it should be in a stored procedure because of the performance and the security concerns and the fact that the DBA just read in a book somewhere that hard-coded SQL was bad.</p>
<p>But in many situations, the performance hit won't be noticeable and depending on your requirements, the security aspect may be moot. The application that spawned this series of articles is an application for my brothers' and dad's company to search for land surveying jobs they've done in the past. Total number of users: six. Security concerns: none. They've been running the current version of the app on hard-coded SQL for over five years now and the only complaints I hear are on lack of features. But what can I say? It's an ASP app and my psychiatrist has forbidden me from looking at it ever again.</p>
<p>But I'm older and wiser now and always on the lookout for ways of making my code not look like it was done by someone just out of high school. So I needed a way of addressing these two issues.</p>
<p>The problem with the delimiited list, it turns out, is pretty easy to solve. I'll describe the thought process I'd like to think I would have gone through had I solved it myself rather than just searching Google Groups.</p>
<p>Like most things in SQL, there are many ways of approaching a problem. Do you use INNER JOIN or a filter in a WHERE clause? Temporary table or table variable? Return a rowset of one column and row or a scalar?</p>
<p>When we examine the problem of filtering on a delimited list of values, we should consider that maybe there's another way of filtering rather than using IN or even WHERE clauses. Namely, using INNER JOINS. What if we had a table of ClientIDs that contained only the ones we wanted to filter on? Then we could do an INNER JOIN on that table, automatically filtering out the ones we don't want.</p>
<p>We know we can declare table variables so our problem reduces to: How can we convert a delimited list of values into a table? Again, judicious use of Google keywords leads us to a SQL function that does just that.</p>
<p>In the database, you'll notice a function called UTILfn_split, which I found <a href="http://www.devx.com/tips/Tip/20009">here</a>. The function is easy enough to understand from a black box perspective: you pass in a delimited list and a delimiter and you get back a table.</p>
<p>In three places, you'll see code that looks like the following:</p>
<p><span style="FONT-FAMILY: 'Courier New'"><span><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span><span style="COLOR: green"><font size="2">-- Get a list of ClientIDs<br /></font></span></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">IF </span>@clientIDList <span style="COLOR: blue">IS NOT NULL AND </span>@clientIDList &lt;&gt; </font><span style="COLOR: maroon"><font size="2">''<br /></font></span></span><span style="FONT-FAMILY: 'Courier New'"><span><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span><span style="COLOR: blue"><font size="2">BEGIN<br /></font></span></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">INSERT INTO </span>@clientIDTable<br /></font></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">SELECT<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>[Value]<br /></font></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">FROM<span>&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>dbo.UTILfn_split( @clientIDList, <span style="COLOR: maroon">',' </span>)<br /></font></span><span style="FONT-FAMILY: 'Courier New'"><span><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span><span style="COLOR: blue"><font size="2">END<br /></font></span></span><span style="FONT-FAMILY: 'Courier New'"><span><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span><span style="COLOR: blue"><font size="2">ELSE<br /></font></span></span><span style="FONT-FAMILY: 'Courier New'"><span><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span><span style="COLOR: blue"><font size="2">BEGIN<br /></font></span></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">INSERT INTO </span>@clientIDTable<br /></font></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">SELECT<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ClientID<br /></font></span><font size="2"><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">FROM<span>&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Clients<br /></span><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">END</span></span></font></p>
<p><span style="FONT-FAMILY: 'Courier New'"><span><font size="2"></font></span></span></p>
<p>In words: If a list of client IDs was passed in, populate my client ID table with the values in the list. Otherwise, populate it with every client ID in the system.</p>
<p>The reason for the IF statement, of course, is that an @clientIDList indicates that we don't actually want to filter on clientID. But we still need to populate the table with something because otherwise, we'd have some conditional logic to determine if we want to do an INNER JOIN, which as far as I know, isn't possible.</p>
<p>Now that we have a table variable with all the client IDs from our filter, the rest of the SQL is easy:</p>
<p><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">SELECT</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>*<br /></font></span><span style="FONT-FAMILY: 'Courier New'"><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">FROM</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>MOO m<br /></font></span><font size="2"><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">INNER</span> <span style="COLOR: blue">JOIN</span><span>&nbsp; </span>@clientIDTable ct<br /></span><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">ON</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>m.ClientID = ct.ClientID</span></font></p>
<p>That is: Get me all the values of Moo that have a matching Client ID in our @clientIDTable variable.</p>
<p>The second issue isn't quite as clean but still lends itself to stored procedures. Earlier, I mentioned that we would need some sort of conditional construct in the WHERE clause to determine how to filter on the Moo Name. While this is true, I kind of lied when I said we were limited to IF and CASE.</p>
<p>This is probably easiest to discuss after looking at the WHERE clause:</p>
<p><font size="2"><font face="Courier New"><span style="COLOR: blue"><span style="FONT-FAMILY: 'Courier New'"><span><font color="#000000" size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></span></span>WHERE <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<br /><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( @nameFilter = 'startswith' AND m.Name LIKE @name + '%' )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">OR</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( @nameFilter = 'endswith' AND m.Name LIKE '%' + @name )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">OR</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( @nameFilter = 'exactly' AND m.Name&nbsp;= @name )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">OR</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( @nameFilter = 'contains' AND m.Name LIKE '%' + @name + '%'&nbsp;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">OR</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( @nameFilter NOT IN ( 'startswith', 'endswith', 'exactly', 'contains' ) )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )</font></span></font></font></p>
<p>So what kind of magic is this? This is easier to understand if you look at the individual pieces of the clause (i.e. the ones separated by OR). The first segment says:</p>
<p><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><font size="2">( @nameFilter = 'startswith' AND m.Name LIKE @name + '%' )</font></span></p>
<p>This is a little easier to follow. Return all results where Moo.Name starts with the specified value but ONLY if @nameFilter = 'startswith'. If @nameFilter doesn't equal 'startswith' this, of course, will fail and we move on to the next OR to see if that succeeds:</p>
<p><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><font size="2">( @nameFilter = 'endswith' AND m.Name LIKE '%' + @name )</font></span></p>
<p>This is a very similar condition. Return all results where Moo.Name ends with the specified value but ONLY if @nameFilter = 'endswith'.</p>
<p>Looking at the two conditions together, if @nameFilter = 'startswith', the first condition will be met and we'll filter on @name + '%'. If @nameFilter = 'endswith', the first condition will not be met but the second one will and we'll filter on '%' + @name. If neither condition is met, we move on to the rest of the statement.</p>
<p>The trick here is to ensure that all possible cases are covered when you compare against @nameFilter. That's why the last condition is:</p>
<p><span style="FONT-FAMILY: 'Courier New'"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><font size="2">( @nameFilter NOT IN ( 'startswith', 'endswith', 'exactly', 'contains' ) )</font></span></p>
<p>This is a catchall. By including this, it means that if @nameFilter doesn't equal one of the previously handled values, don't filter on Moo.Name at all. Which is why there isn't a filter condition after it as in the other ones.</p>
<p>Using these two techniques, along with the usual SQL suspects, we are able to get a pretty robust search mechanism in our stored procedure. If we wanted to, we could also combine this procedure with Microsoft Index Services. This would allow us to not only search metadata about a group of documents, but also search the contents of the documents themselves. A cost-effective way of doing document searches for cheap-ass family members who don't want to buy Windows 2003 for Sharepoint Services.</p>
<p>I should mention that there is now another way of addressing this problem, thanks to SQL Server 2005. That is, you can use SQL Server's CLR integration to run managed code directly from the database.</p>
<p>I'm making it sound like I know more about this than I do but I haven't actually done this in any way, shape, or form. From what I've heard, though, it is probably a very viable alternative, provided you are targeting SQL Server 2005 in your application. At the very least, you could probably replace the UTILfn_split function with managed code as it probably runs much cleaner and faster in the CLR. And I'm guessing you could make use of an enum for the @nameFilter parameter which would be a little less unstable. I'm sure I'll blather on this when I start experimenting, though.</p>
<p>Finally, credit to <a href="http://jargon.watson-net.com/">http://jargon.watson-net.com/</a> for the web service I used to generate the data. At present, the database has only fifty entries in the Moo table but if you navigate to SearchPontification/GenerateData.aspx, you can generate more. Note that since this is a web service, it will take a bit to generate each word so be prepared to wait if you put in more than, say, 100.</p>
