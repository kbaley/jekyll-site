---
layout: post
title: 'Batter-fried Batter: Yum'
date: 2006-05-29 02:25:00.000000000 -04:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  pvc_views: '905'
  dsq_thread_id: '362996442'
author:
  login: kyle6994
  email: kyle@baley.org
  display_name: Kyle Baley
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>I believe XSL is more underused than it should be. Few people at the recent <a href="http://www.calgarycodecamp.com">code camp</a> were familiar with it and it is my experience that people are aware of it and what it does but may not know how it does it.</p>
<p>XSL is used to convert an XML document into another format. The other format can be another XML document, HTML, text or any other format (and as far as I know, it has to be a text-based format). There are many good tutorials on XSL (my favorite resource is <a href="http://www.dpawson.co.uk/xsl/index.html">here</a>;&nbsp;check out the Questions and Answers section) so I'm going to focus on a couple of the more obscure things.</p>
<p><em><strong>xsl:apply-templates vs. xsl:for-each<br /></strong></em>While XSL is underused, the xsl:for-each construct is, in my opinion, overused. People use it because they understand it. It has a direct correlation to modern programming languages and programmers know intuitively how it works. I almost never use it.</p>
<p>The next time you want to put in an xsl:for-each, consider using a separate template instead. That's what templates are for. Say, for example, you are building a table to display a list of Songs. Your XML would have a Songs root element with one or more Song elements. And perhaps each Song element has one or more Genre elements.</p>
<p>This, to me, warrants three templates: one for the Songs element, one for each Song element, and one for each Genre. The template for the Songs element looks like this (in pseudocode):<br /><font face="Courier New">&nbsp;&lt;xsl:template match="Songs"&gt;<br />&nbsp;&nbsp;&lt;table width="100%"&gt;<br />&nbsp;&nbsp;&nbsp;&lt;thead&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;Title&lt;/th&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;Artist&lt;/th&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;Genres&lt;/th&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;<br />&nbsp;&nbsp;&nbsp;&lt;/thead&gt;<br />&nbsp;&nbsp;&nbsp;&lt;tbody&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsl:apply-templates select="Song" /&gt;<br />&nbsp;&nbsp;&nbsp;&lt;/tobdy&gt;<br />&nbsp;&nbsp;&lt;/table&gt;<br />&nbsp;&lt;/xsl:template&gt;<br /></font>&nbsp;<br />Notice where it uses &lt;xsl:apply-templates&gt;. This is where someone else may use &lt;xsl:for-each&gt;. As in, "for each song, output the following HTML". xsl:for-each lends itself to a small number of monolithic templates, rather than a larger number of small (and re-usable) templates. In my version, it says "apply the songs template for each Song element". It's almost the same thing but with a separate Song template, we can re-use it in another template or even another XML document. And if you want to change how the Song is displayed, it's easier to zero in on its template without wading through the Songs template.</p>
<p>A similar argument goes for displaying Genres within the Song template:<br /><font face="Courier New">&nbsp;&lt;xsl:template match="Song"&gt;<br />&nbsp;&nbsp;&lt;tr&gt;<br />&nbsp;&nbsp;&nbsp;&lt;td&gt;&lt;xsl:value-of select="SongTitle" /&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&nbsp;&lt;td&gt;&lt;xsl:value-of select="Artist" /&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&nbsp;&lt;td&gt;&lt;xsl:apply-templates select="Genre" /&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&lt;/tr&gt;<br />&nbsp;&lt;/xsl:template&gt;</font><br />&nbsp;<br />In this case, we output a single table row for each song. The list of genres will appear in a single table cell in some form (e.g. an unordered list or a comma-delimited list). Again, we keep the focus on the song, and not the extraneous stuff. An argument could be made here that Genre is insignificant enough that it could be included using xsl:for-each. I'll listen to that argument but still prefer to use templates for the most part.</p>
<p><strong><em>The root template<br /></em></strong>In many XSL documents, I'll see a template like this: &lt;xsl:template match="/"&gt;. To me, this obviously matches the root element of the XML and is the template that triggers the whole thing.</p>
<p>Maybe it's my compulsive nature but I prefer not to use "/" in a template. In reality, it says, "apply this template to every element no matter what it is". The only thing that keeps it from rendering every element in your DOM is careful (and in many case, lucky) use of &lt;xsl:apply-templates&gt; elsewhere in your document. When you use &lt;xsl:apply-templates&gt;, it will find the template that most closely matches your select attribute. In my above example, &lt;xsl:apply-templates select="Song" /&gt; will look for a template that specifically matches Song. If one isn't found, it will use the one that matches "/" (provided no other&nbsp;less general templates exist).</p>
<p>This seems dangerous to me even if it usually doesn't turn out that way in practice. But if you know your root node is named "Songs", why not include a template that specifically matches "Songs"? It's more consistent with the rest of your templates and avoids any accidental use of the default template. Which is how it should be used: as a default template. I.E. If no other templates match, use this as the default template. Useful for formatting individual text the way you like it without having to create a template for every node.</p>
<p><strong><em>Default namespaces</em></strong><br />XSL doesn't like 'em. Well, that's not totally true. XSL can deal with them just fine. But you may not be able to deal with how XSL uses them.</p>
<p>Say our Songs.xml file uses a default namespace: xmlns="http://www.suvius.com". This means that every node in the XML will be qualified with that namespace (if it isn't already explicitly qualified with another one). So when I say &lt;xsl:apply-templates select="Song" /&gt;, XSL won't find any nodes. In this case, it's looking for unqualified Song nodes, which don't exist. The end result is that your transformation will show a whole lot of white space when you're expecting HTML.</p>
<p>To do this properly, you need to add that default namespace to your XSL...but not as a default namespace itself. Using the same default namespace mentioned in the previous paragraphy, I would add the following to the &lt;xsl:stylesheet&gt; element: xmlns:suvius="http://www.suvius.com". That is, the default namespace in the XML document is a named namespace in the XSL document.</p>
<p>Now, when I want to apply a template or reference a node, it'll look like this: &lt;xsl:apply-templates select="suvius:Song" /&gt;.</p>
<p>Consider namespaces to be a substitution. I.E. XSL will replace the namespace with its contents. If a default namespace is used, all unqualified nodes in the XML will have that namespace prepended to it. So my Song node in the XML document is processed as if it looks like this: http://www.suvius.com:Song.</p>
<p>By adding a named namespace to the XSL, I would reference this node in the XSL document using suvius:Song, which the parser would convert to http://www.suvius.com:Song, thus matching the node in the original XML document.</p>
<p>A lot of work, to be sure. And the best way around this is: don't use default namespaces. Easier said than done when using web services. When you specify a namespace on a web service, it will be converted to a default namespace when the object being returned is serialized to XML. Depending on your needs, you can specify a blank namespace in your web service, which means no default namespace will be used. This might raise other concerns, though, especially if&nbsp;it is a public service.</p>
<p>This post was auto-generated by my fingers.</p>
