---
layout: post
title: Do the right thing. Assuming you know what that is.
date: 2008-09-20 22:31:03.000000000 -04:00
categories: []
tags:
- Community
- Conscientious Coding
status: publish
type: post
published: true
meta:
  hl_twitter_has_auto_tweeted: 'New post: Do the right thing. Assuming you know what
    that is., Full text: http://blog.baley.org/?p=112'
  pvc_views: '1175'
  dsq_thread_id: '799836294'
author:
  login: kyle6994
  email: kyle@baley.org
  display_name: Kyle Baley
  first_name: ''
  last_name: ''
---
<p>I have kind of a love/hate thing going for <a href="http://weblogs.asp.net/ROsherove/" target="_blank">Roy Osherove's blog</a>. The &quot;hate&quot; part comes because he always challenges my perspective when I least expect it. <a href="http://weblogs.asp.net/rosherove/archive/2008/01/18/dependency-injection-is-it-relevant-beyond-unit-testing.aspx" target="_blank">Some</a> of his <a href="http://weblogs.asp.net/rosherove/archive/2008/01/17/is-typemock-too-powerful-will-it-kill-design-for-testability.aspx" target="_blank">posts</a> seem like they are baiting people and it is easy to discount them as biased based on his position with <a href="http://www.typemock.com/" target="_blank">TypeMock</a>.</p>
<p>But given what I think I know about him, I read these &quot;inflammatory&quot; posts with a different view. That is, as someone who is challenging the view of my personal echo chamber. I read tons of posts extolling the virtues of mock objects and Rhino Mocks. So it hurts my little brain to see someone I respect saying it's okay to keep your current &quot;creative&quot; design and still be able to test it.</p>
<p>It starts, &quot;Yeah, whatever. Like I'd ever do that.&quot; Then I start mulling it over and grumble to myself, &quot;well, I guess that would have made sense in this past situation&quot;, then &quot;actually, that makes sense for quite a few scenarios.&quot; Eventually, the train of though leads to my lying on my bed sobbing on the phone with my old employer to apologize for the colourful analogies I made to describe his project when I was unceremoniously let go for rocking the boat too much. Which is an interesting thing to account for when drawing up the timesheet for my <em>current</em> contract.</p>
<p>Anyway, this Roy-love isn't the real reason for this post but hopefully, you're used to the hillbilly's verbose lead-ins. </p>
<p>Roy's most <a href="http://weblogs.asp.net/rosherove/archive/2008/09/20/goodbye-mocks-farewell-stubs.aspx" target="_blank">recent post</a> is another example of one that seemed bound from the beginning to give me a headache just from the title alone. But luckily, it touches on a subject I've thought about before, particularly when dealing with the fledgling Bahamian software industry.</p>
<p>I won't paraphrase because chances are, you've read it already but the question it tickled in my mind was, &quot;Are the best practices I've adopted over the last two years practical?&quot;</p>
<p>I've mentioned this a <a href="http://codebetter.com/blogs/kyle.baley/archive/2008/04/11/who-s-the-next-guy.aspx" target="_blank">little before</a> from the perspective of a small application for my family who can't afford a senior developer should I take up shark-baiting in the near future. And it's going to be hard to talk about this without sounding elitist so I'll call up the good will of my 98 previous posts at CodeBetter and hope y'all assume the best.</p>
<p>I took <a href="http://blog.jpboodhoo.com/" target="_blank">JP's Nothing But .NET</a> course over a year ago and had an <a href="http://kyle.baley.org/CommentView,guid,49505e00-dff9-4e50-bdeb-d2ee3f2ae023.aspx" target="_blank">absolute blast</a>. But quite a lot of people struggled with it. Since then, I've made a more concerted effort to learn more about things like mocking, dependency injection, the SOLID principles, etc, etc, and so on and so forth. It hasn't always been easy but it's been tremendously rewarding. Learning all of it has made development fun again. Plus it's allowed me to connect with a ton of other people both as mentor and learner. And as a mentor, I've seen my share of people struggle with it. Even before I started, I saw a lot of people fight to understand things like AJAX calls, NAnt scripts, even CSS.</p>
<p>By all accounts, these are reasonably bright people. They want to do a good job and are receptive to new ideas. But quite frankly, some of these things are hard. Let no one forget that learning how to properly use mock objects is *not* an easy task and until you &quot;get&quot; them, they will seem like unnecessary overhead. I resisted TDD for many a moon. Even today, it's still not quite second nature. That's mostly because I'm stuck in Livelink-land these days which contains code that would make <a href="http://michaelfeathers.typepad.com/" target="_blank">Michael Feathers</a> shake his head in defeat.</p>
<p>When I entertain these thoughts, it's usually a battle between &quot;should we cool our heels a bit until we hit the tipping point&quot; and &quot;should we keep going full tilt until the message starts getting across&quot;. As Roy mentions in his point, the learning curve is high. Do we keep pushing the learning so that more people get over it or do we lower the learning curve until most people get it, then raise it a little?</p>
<p> I'd like to think we can do the first. The second seems like giving up. And worse, if we start to &quot;dumb things down&quot; in actual projects, it will be that much harder to actually lower the learning curve because no one will be pushing the boundaries. No Fluent NHibernate, no MvcContrib (or even ASP.NET MVC), no StructureMap. We've all seen what teaching to the lowest common denominator has done for the North American education system.</p>
<p>Yes, we can put the onus on programmers to &quot;do a better job&quot; but let's face it, these people have lives. My dad is a land surveyor and my mom was a registered nurse. By all accounts, they were/are very good at their jobs and I remember very few instances of them taking their work home with them or advancing their learning outside of their work. With software development, it is almost expected that if you want to get better, you need to do it on your own time. And when you're done, you face going in to work to find that the rest of your team hasn't done their part and thus, are not amenable to the changes you want to make.</p>
<p>So how far can we reasonably push people? The work needs to actually get done and it seems a good chunk of programmers still don't put any special effort into making code maintainable over the long term. Do we need to change the message? Or the medium? Are user groups and code camps doing their part or simply enforcing the status quo? Is alt.net making a difference or fragmenting the industry? Or simply being ignored?</p>
<p>Will be interested in hearing people's comments on this as I actually have an over-arching reason for this line of questioning.</p>
<p>Lord Tunderin' Jayzus, what a friggen essay this turned out to be. Now I gotta go dig up a couple of halfway-relevant images to balance out this tome. Serves me right for thinkin'.</p>
<p>Kyle the Introspective</p>
